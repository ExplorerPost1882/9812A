#pragma config(Motor,  port2,           X2Y1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           X2Y2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           X1Y1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           X1Y2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Claw1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Claw2,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


//PRE_AUTON------------------------------------------------------------------------
void pre_auton()
{

  bStopTasksBetweenModes = true;


}

//AUTONOMOUS-------------------------------------------------------------------------

task autonomous()
{

  AutonomousCodePlaceholderForTesting();
}
//USERCONTROL-----------------------------------------------------------------------

task usercontrol()
{


  while (true)
  {
   motor[Arm1] = vexRT[Ch1Xmtr2];
   motor[Arm2] = vexRT[Ch1Xmtr2];
   motor[Claw1] = vexRT[Ch3Xmtr2];
   motor[Claw2] = vexRT[Ch3Xmtr2];
   motor[X2Y1] = vexRT[Ch3]+vexRT[Ch4];
   motor[X1Y1] = vexRT[Ch3]-vexRT[Ch4];
   motor[X2Y2] = vexRT[Ch2]-vexRT[Ch1];
   motor[X1Y2] = vexRT[Ch2]+vexRT[Ch1];



    UserControlCodePlaceholderForTesting();
  }
}
