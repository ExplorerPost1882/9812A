#pragma config(Sensor, dgtl1,  EncoX2Y1,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoX2Y2,       sensorQuadEncoder)
#pragma config(Motor,  port2,           X2Y1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           X1Y1,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           X2Y2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           X1Y2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Claw1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Claw2,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//moverobot(sydeways, rotate, firword/back, 0, aut or not, speed for auto)

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"



//PRE_AUTON------------------------------------------------------------------------
void pre_auton()
{

	bStopTasksBetweenModes = true;

}
//functions-------------------------------------------------------------------------

void drive (float dist, float angle, float speed)
{
	float c=3.75*PI;//finds circumfrence
	float rn=dist/c;//finds rotations needed
	SensorValue[EncoX2Y1] = 0;//sets encoder to zero
	SensorValue[EncoX2Y2] = 0;//sets encoder to zero
	float ra=0;//gives variable for motor X2Y2 rotations
	float rb=0;//gives variable for motor X2Y1 rotations
	float vCh1=sinDegrees(angle)*speed;//     ^
	float vCh2=cosDegrees(angle)*speed;//     ^
	float vCh3=cosDegrees(angle)*speed;//     ^
	float vCh4=sinDegrees(angle)*speed;//<--- ^this and above gives vaiables for motors based on direction of joystick
	while (sqrt(ra*ra+rb*rb)<rn)//formula for part of pathagorean theorem
	{

	  motor[X2Y1] = vCh3+vCh4;
		motor[X1Y1] = vCh3-vCh4;
		motor[X2Y2] = vCh2-vCh1;
		motor[X1Y2] = vCh2+vCh1;
		ra=SensorValue[EncoX2Y2]/90.0;
		rb=SensorValue[EncoX2Y1]/90.0;

	}
	motor[X1Y1] = 0;
	motor[X1Y2] = 0;
	motor[X2Y1] = 0;
	motor[X2Y2] = 0;
}

//AUTONOMOUS-------------------------------------------------------------------------

task autonomous()
{

	AutonomousCodePlaceholderForTesting();
}
//USERCONTROL-----------------------------------------------------------------------

task usercontrol()
{


		motor[Arm1] = vexRT[Ch1Xmtr2];
		motor[Arm2] = vexRT[Ch1Xmtr2];
		motor[Claw1] = vexRT[Ch3Xmtr2];
		motor[Claw2] = vexRT[Ch3Xmtr2];
	  motor[X2Y1] = vexRT[Ch3]+vexRT[Ch4];
		motor[X1Y1] = vexRT[Ch3]-vexRT[Ch4];
		motor[X2Y2] = vexRT[Ch2]-vexRT[Ch1];
		motor[X1Y2] = vexRT[Ch2]+vexRT[Ch1];



		UserControlCodePlaceholderForTesting();
	}
